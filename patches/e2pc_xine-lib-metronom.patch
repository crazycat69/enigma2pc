--- a/enigma2pc/enigma2/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-12-02 19:18:48.000000000 +0400
@@ -87,6 +87,9 @@
 		self.list.append(getConfigListEntry(_("TV resolution width"), config.pc.initial_window_width))
 		self.list.append(getConfigListEntry(_("TV resolution height"), config.pc.initial_window_height))
 
+		self.list.append(getConfigListEntry(_("HD prebuffer metronom"), config.pc.prebuffer_metronom_hd))
+		self.list.append(getConfigListEntry(_("SD prebuffer metronom"), config.pc.prebuffer_metronom_sd))
+
 		if level >= 1:
 			if SystemInfo["CanDownmixAC3"]:
 				self.list.append(getConfigListEntry(_("AC3 downmix"), config.av.downmix_ac3))
--- a/enigma2pc/enigma2/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-12-02 19:18:48.000000000 +0400
@@ -76,6 +76,11 @@
 		config.pc.initial_window_width = ConfigSelection(choices = {"0": _("0"), "720": _("720"), "1280": _("1280"), "1366": _("1366"), "1600": _("1600"), "1680": _("1680"), "1920": _("1920")}, default="0")
 		config.pc.initial_window_height = ConfigSelection(choices = {"0": _("0"), "576": _("576"), "720": _("720"), "768": _("768"), "1050": _("1050"), "1080": _("1080"), "1200": _("1200")}, default="0")
 
+		config.pc.prebuffer_metronom_hd = ConfigSelection(choices = {"90000": _("1"), "100000": _("1.1"), "108000": _("1.2"), "117000": _("1.3"), "126000": _("1.4"), "135000": _("1.5"), "145000": _("1.6")}, default="126000")
+		config.pc.prebuffer_metronom_sd = ConfigSelection(choices = {"55000": _("0.6"), "63000": _("0.7"), "72000": _("0.8"), "81000": _("0.9"), "90000": _("1"), "100000": _("1.1")}, default="72000")
+		config.pc.prebuffer_metronom_hd.addNotifier(self.updateBufMetronom)
+		config.pc.prebuffer_metronom_sd.addNotifier(self.updateBufMetronom)
+
 		# until we have the hotplug poll socket
 #		self.timer = eTimer()
 #		self.timer.callback.append(self.readPreferredModes)
@@ -108,6 +113,7 @@
 
 		self.updateDeinterlace(None)
 		self.updateSDfeatures(None)
+		self.updateBufMetronom(None)
 		self.updateAspect(None)
 
 	def saveMode(self, port, mode, rate):
@@ -190,6 +196,10 @@
 		print "-> update SD features !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
 		eAVSwitch.getInstance().setSDfeatures(int(config.pc.sd_sharpness.value), int(config.pc.sd_noise.value))
 
+	def updateBufMetronom(self, cfgelement):
+		print "-> update Prebuffer Metronom !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
+		eAVSwitch.getInstance().setBufMetronom(int(config.pc.prebuffer_metronom_hd.value), int(config.pc.prebuffer_metronom_sd.value))
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
--- a/enigma2pc/enigma2/lib/driver/avswitch.h	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/driver/avswitch.h	2013-12-02 19:18:48.000000000 +0400
@@ -38,6 +38,7 @@
 	void setWSS(int val);
 	void setDeinterlace(int global, int sd, int hd);
  	void setSDfeatures(int sharpness, int noise);
+ 	void setBufMetronom(int hd, int sd);
 	bool isActive();
 	PSignal1<void, int> vcr_sb_notifier;
 };
--- a/enigma2pc/enigma2/lib/driver/avswitch.cpp	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/driver/avswitch.cpp	2013-12-02 19:18:48.000000000 +0400
@@ -316,5 +316,11 @@
 	cXineLib::getInstance()->setSDfeatures(sharpness, noise);
 }
 
+void eAVSwitch::setBufMetronom(int hd, int sd)
+{
+        cXineLib *xineLib = cXineLib::getInstance();
+        cXineLib::getInstance()->setBufMetronom(hd, sd);
+}
+
 //FIXME: correct "run/startlevel"
 eAutoInitP0<eAVSwitch> init_avswitch(eAutoInitNumbers::rc, "AVSwitch Driver");
--- a/enigma2pc/enigma2/lib/service/servicedvb.cpp	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/service/servicedvb.cpp	2013-12-03 23:36:31.000000000 +0400
@@ -1177,6 +1177,31 @@
 	case eDVBServicePMTHandler::eventNewProgramInfo:
 	{
 		eDebug("eventNewProgramInfo %d %d", m_timeshift_enabled, m_timeshift_active);
+
+                /* OpenPliPC */
+                ePtr<iDVBDemux> demux;
+                if ((!m_is_pvr && !m_service_handler.getDataDemux(demux)) &  !m_timeshift_enabled)
+                {
+                        printf("Start live TV!\n");
+
+                        demux->createTSRecorder(m_openpliPC_record);
+                        if (!m_openpliPC_record)
+                                return;
+                
+                        if (m_openpliPC_fd < 0)
+                        {
+                                m_openpliPC_record = 0;
+                                return;
+                        }
+                        m_openpliPC_record->setTargetFD(m_openpliPC_fd);
+                        m_openpliPC_record->setTargetFilename(m_openpliPC_file);
+                        m_openpliPC_record->enableAccessPoints(false);
+			updateTimeshiftPids(); // workaround to set PIDs
+                        m_openpliPC_record->start();
+
+                        printf("Start live TV END\n");
+                }
+
 		if (m_timeshift_enabled)
 			updateTimeshiftPids();
 		if (!m_timeshift_active)
@@ -1189,30 +1214,6 @@
 		if (!m_timeshift_active)
 			m_event((iPlayableService*)this, evUpdatedInfo);
 
-		/* OpenPliPC */
-		ePtr<iDVBDemux> demux;
-		if ((!m_is_pvr && !m_service_handler.getDataDemux(demux)) &  !m_timeshift_enabled)
-		{
-			printf("Start live TV!\n");
-
-			demux->createTSRecorder(m_openpliPC_record);
-			if (!m_openpliPC_record)
-				return;
-		
-			if (m_openpliPC_fd < 0)
-			{
-				m_openpliPC_record = 0;
-				return;
-			}
-			m_openpliPC_record->setTargetFD(m_openpliPC_fd);
-			m_openpliPC_record->setTargetFilename(m_openpliPC_file);
-			m_openpliPC_record->enableAccessPoints(false);
-			updateTimeshiftPids(); // workaround to set PIDs
-			m_openpliPC_record->start();
-
-			printf("Start live TV END\n");
-		}
-
 		m_event((iPlayableService*)this, evNewProgramInfo);
 		break;
 	}
@@ -1384,6 +1385,12 @@
 		m_event(this, evStart);
 	}
 
+	cXineLib *xineLib = cXineLib::getInstance();
+	if (m_timeshift_changed)
+		xineLib->setScrambled(false);
+	else
+		xineLib->setScrambled(scrambled);
+
 	m_first_program_info = 1;
 	ePtr<iTsSource> source = createTsSource(service, packetsize);
 	m_service_handler.tuneExt(service, m_is_pvr, source, service.path.c_str(), m_cue, false, m_dvb_service, type, scrambled);
--- a/enigma2pc/enigma2/lib/base/rawfile.cpp	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/base/rawfile.cpp	2013-12-05 19:38:30.000000000 +0400
@@ -3,6 +3,7 @@
 #include <fcntl.h>
 #include <lib/base/rawfile.h>
 #include <lib/base/eerror.h>
+#include <lib/gdi/xineLib.h>
 
 DEFINE_REF(eRawFile);
 
@@ -194,7 +195,7 @@
 eDecryptRawFile::eDecryptRawFile(int packetsize)
  : eRawFile(packetsize)
 {
-	ringBuffer = new cRingBufferLinear(KILOBYTE(2024),TS_SIZE,true,"IN-TS");
+	ringBuffer = new cRingBufferLinear(KILOBYTE(2048),TS_SIZE,true,"IN-TS");
 	ringBuffer->SetTimeouts(100,100);
 	bs_size = dvbcsa_bs_batch_size();
 	delivered=false;
@@ -289,6 +290,10 @@
 					printf("-------------------- I have PES ---------------------- %02X\n", wsk[3]);
 					ret = (packetsCount-i)*TS_SIZE;
 					memcpy(buf, packet, (packetsCount-i)*TS_SIZE);
+// When channel descramble, then start xineLib-playVideo()
+					cXineLib *xineLib = cXineLib::getInstance();
+					xineLib->setScrambled(false);
+					xineLib->playVideo();
 					break;
 				}
 			}
--- a/enigma2pc/enigma2/lib/gdi/xineLib.h	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/gdi/xineLib.h	2013-12-02 19:18:48.000000000 +0400
@@ -25,6 +25,7 @@
         xine_streamtype_data_t  videoData, audioData;
 
 	bool                    videoPlayed;
+	bool			doDescramble;
 	int                     osdWidth, osdHeight;
 	int                     windowWidth, windowHeight;
 
@@ -32,10 +33,11 @@
 	int m_windowAspectRatio, m_policy43, m_policy169;
 	int m_zoom43_x, m_zoom43_y, m_zoom169_x, m_zoom169_y;
 	int m_sharpness, m_noise;
+	int m_streamtype;
+        int m_hd, m_sd;
 
 	void setStreamType(int video);
-
-//	void detect_aspect_from_frame(bool b_aspect);
+	void setLiveTV(int v_streamtype);
 
 	static void xine_event_handler(void *user_data, const xine_event_t *event);
 
@@ -100,6 +102,8 @@
 	void setPolicy43(int mode);
 	void setPolicy169(int mode);
 	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
+	void setBufMetronom(int hd, int sd);
+	void setScrambled(bool doDescramble);
 };
 
 #endif
--- a/enigma2pc/enigma2/lib/gdi/xineLib.cpp	2013-09-04 13:13:39.000000000 +0400
+++ b/enigma2pc/enigma2/lib/gdi/xineLib.cpp	2013-12-05 19:30:38.000000000 +0400
@@ -30,13 +58,14 @@
 	char        configfile[150];
 	char        *vo_driver = "auto";
 	char        *ao_driver = "alsa";
-	const char  *static_post_plugins = "enigma_video;upmix_mono";
+	const char  *static_post_plugins = "enigma_video;enigma_audio;upmix_mono";
 
 	instance = this;
 	osd = NULL;
 	stream = NULL;
 	end_of_stream = false;
 	videoPlayed = false;
+	doDescramble = false;
 	post_plugins_t *posts = NULL;
 
 	printf("XINE-LIB version: %s\n", xine_get_version_string() );
@@ -122,6 +151,16 @@
 
 	m_sharpness = 0;
 	m_noise = 0;
+
+	m_streamtype = -1;
+
+	m_hd = getConfigInt("config.pc.prebuffer_metronom_hd");
+	m_sd = getConfigInt("config.pc.prebuffer_metronom_sd");
+
+	if (m_hd == 0)
+	        m_hd = 126000;
+	if (m_sd == 0)
+	        m_sd = 72000;
 }
 
 cXineLib::~cXineLib() {
@@ -153,6 +192,8 @@
 		xine_close_audio_driver(xine, ao_port);
 	if (vo_port)
 		xine_close_video_driver(xine, vo_port);
+
+	xine_exit(xine);
 }
 
 void cXineLib::rewire_posts_load() {
@@ -198,17 +239,32 @@
 	xine_osd_set_argb_buffer(osd, argb_buffer, 0, 0, osdWidth, osdHeight);
 }
 
+void cXineLib::setScrambled(bool doDescrambleChannel) {
+	printf("doDescrambled Channel: %s\n", doDescrambleChannel ? "true" : "false");
+	doDescramble = doDescrambleChannel;
+}
+
 void cXineLib::playVideo(void) {
+	if (doDescramble) {
+//		doDescramble = false;
+		return;
+	}
+
 	end_of_stream = false;
 	videoPlayed = false;
 
+        if (m_streamtype == 3)
+                setPrebuffer(m_hd);
+        else if (m_streamtype == 2)
+                setPrebuffer(m_sd);
+        else if (m_streamtype == 1)
+                setPrebuffer(25000);
+
 	printf("XINE try START !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
 	if ( !xine_open(stream, "enigma:/") ) {
 		printf("Unable to open stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
 	}
 
-	//	setStreamType(1);
-	//	setStreamType(0);
 	xine_pids_data_t data;
 	xine_event_t event;
 	event.type = XINE_EVENT_PIDS_CHANGE;
@@ -226,16 +282,17 @@
 	setStreamType(1);
 	setStreamType(0);
 
-        //_x_demux_control_start(stream);
-        //_x_demux_seek(stream, 0, 0, 0);
-
-//	rewire_posts_load();
-
+/*        if (doDescramble) {
+                setScrambled(false);
+                return;
+        }
+*/
 	if( !xine_play(stream, 0, 0) ) {
 		printf("Unable to play stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
 	}
 	else {
 		printf("XINE STARTED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+		printf("STILL, FIRST, CONTROL, SEEK FRAME\n");
 		videoPlayed = true;
 	}
 }
@@ -243,6 +300,7 @@
 void cXineLib::stopVideo(void) {
 
 	if (videoPlayed) {
+//		xine_close(stream);
 		xine_stop(stream);
 		end_of_stream = true;
 		videoPlayed = false;
@@ -268,6 +326,11 @@
 void cXineLib::setVideoType(int pid, int type) {
 	videoData.pid = pid;
 	videoData.streamtype = type;
+
+	if (type == 27)
+		setLiveTV(3); // HD Live mode
+	else
+		setLiveTV(2); // SD Live mode
 }
 
 //////////////////////7
@@ -299,20 +362,19 @@
 int
 cXineLib::VideoPause()
 {
-xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
-return 1;
+//	_x_set_speed (stream, XINE_SPEED_PAUSE);
+//	stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0);
+	xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
+	return 1;
 }
 
 
 int
 cXineLib::VideoResume()
 {
-//	int ret;
-	/* Resume the playback. */
-//	ret = xine_get_param(stream, XINE_PARAM_SPEED);
-//	if( ret != XINE_SPEED_NORMAL ){
-		xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
-//	}
+	xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
+//	_x_set_speed (stream, XINE_SPEED_NORMAL);
+//	stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
 	return 1;
 }
 
@@ -366,9 +428,11 @@
 	audioData.pid = pid;
 	audioData.streamtype = type;
 	
-	if (videoPlayed) {
-	    setStreamType(0);
-	}
+	if (videoPlayed)
+		setStreamType(0);
+	else
+		setLiveTV(1); //  Radio mode
+
 }
 
 int cXineLib::getNumberOfTracksAudio() {
@@ -400,39 +464,21 @@
 	return lang;
 }
 
+void cXineLib::setLiveTV(int streamtype)
+{
+	m_streamtype = streamtype;
+}
+
 void cXineLib::setPrebuffer(int prebuffer) {
 	xine_set_param(stream, XINE_PARAM_METRONOM_PREBUFFER, prebuffer);
 }
 
-/* void cXineLib::detect_aspect_from_frame(bool b_aspect)
+void cXineLib::setBufMetronom(int hd, int sd)
 {
-        int old_height, old_width;
-        xine_current_frame_data_t frame_data;
-        memset(&frame_data, 0, sizeof (frame_data));
-	old_height=old_width=-1;
-
-        while (b_aspect)
-        {
-                if (xine_get_current_frame_data(this->stream, &frame_data, XINE_FRAME_DATA_ALLOCATE_IMG))
-                {
-                   /*     cur_aspect=frame_data.ratio_code;
-                        if ((cur_aspect != old_aspect) && (old_aspect<0))
-                        {
-                                printf("Aspect changed from %d to %d !!!\n", old_aspect, cur_aspect);
-                        }
-			old_aspect=cur_aspect;
-		* /
-			printf("Current height - %d, current width - %d, old height - %d, old  width - %d !!!\n", frame_data.crop_left, frame_data.crop_right, frame_data.crop_top, frame_data.crop_bottom);
-			old_height = frame_data.height;
-			old_width = frame_data.width;
-                }
-		sleep(1);
-
-        }
-
-
+        m_hd = hd;
+        m_sd = sd;
 }
-*/
+
 void cXineLib::xine_event_handler(void *user_data, const xine_event_t *event)
 {
 	cXineLib *xineLib = (cXineLib*)user_data;
--- a/enigma2pc/xine-lib/src/input/Makefile.am	2013-09-17 13:40:17.000000000 +0400
+++ b/enigma2pc/xine-lib/src/input/Makefile.am	2013-10-31 19:24:51.000000000 +0400
@@ -161,6 +161,6 @@
 xineplug_inp_bluray_la_LIBADD = $(XINE_LIB) $(LIBBLURAY_LIBS) $(PTHREAD_LIBS) $(LTLIBINTL)
 xineplug_inp_bluray_la_CFLAGS = $(AM_CFLAGS) $(LIBBLURAY_CFLAGS)
 
-xineplug_inp_enigma_la_SOURCES = combined_enigma.c combined_enigma.h input_enigma.c net_buf_ctrl.c post_enigma_video.c
+xineplug_inp_enigma_la_SOURCES = combined_enigma.c combined_enigma.h input_enigma.c net_buf_ctrl.c post_enigma_video.c post_enigma_audio.c
 xineplug_vdr_la_CFLAGS = $(AM_CFLAGS) -fno-strict-aliasing
 xineplug_inp_enigma_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
--- a/enigma2pc/xine-lib/src/input/combined_enigma.h	2013-09-04 13:13:43.000000000 +0400
+++ b/enigma2pc/xine-lib/src/input/combined_enigma.h	2013-10-31 19:24:51.000000000 +0400
@@ -73,7 +73,7 @@
 /* plugin class initialization function */
 void *init_class(xine_t *xine, void *data);
 void *enigma_video_init_plugin(xine_t *xine, void *data);
-//void *vdr_audio_init_plugin(xine_t *xine, void *data);
+void *enigma_audio_init_plugin(xine_t *xine, void *data);
 
 
 
--- a/enigma2pc/xine-lib/src/input/combined_enigma.c	2013-09-04 13:13:43.000000000 +0400
+++ b/enigma2pc/xine-lib/src/input/combined_enigma.c	2013-10-31 19:24:51.000000000 +0400
@@ -38,7 +38,7 @@
   { PLUGIN_INPUT,  18, "ENIGMA"      , XINE_VERSION_CODE, NULL                   , &init_class },
   { PLUGIN_POST ,  10, "enigma"      , XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
   { PLUGIN_POST ,  10, "enigma_video", XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
-//  { PLUGIN_POST ,  10, "vdr_audio", XINE_VERSION_CODE, &vdr_audio_special_info, &vdr_audio_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_audio", XINE_VERSION_CODE, &enigma_audio_special_info, &enigma_audio_init_plugin },
   { PLUGIN_NONE ,   0, ""         , 0                , NULL                   , NULL }
 };
 
--- a/enigma2pc/xine-lib/src/input/post_enigma_video.c	2013-09-04 13:13:43.000000000 +0400
+++ b/enigma2pc/xine-lib/src/input/post_enigma_video.c	2013-10-31 19:24:51.000000000 +0400
@@ -334,8 +334,8 @@
     this->old_frame_ratio  = 0;
   }
 
-  if (!this->enigma_stream
-      && enigma_is_stream(stream))
+  if (!this->enigma_stream)
+//      && enigma_is_stream(stream))
   {
     this->event_queue = xine_event_new_queue(stream);
     if (this->event_queue)
--- a/enigma2pc/xine-lib/src/input/post_enigma_audio.c	1970-01-01 03:00:00.000000000 +0300
+++ b/enigma2pc/xine-lib/src/input/post_enigma_audio.c	2013-10-31 19:24:51.000000000 +0400
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * select audio channel plugin for VDR
+ */
+
+#define LOG_MODULE "enigma_audio"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_audio_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  uint8_t audio_channels;
+  int num_channels;
+
+}
+enigma_audio_post_plugin_t;
+
+
+static void enigma_audio_select_audio(enigma_audio_post_plugin_t *this, uint8_t channels)
+{
+  this->audio_channels = channels;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_audio_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_audio_dispose(post_plugin_t *this_gen);
+
+/* replaced ao_port functions */
+static int            enigma_audio_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                                          uint32_t bits, uint32_t rate, int mode);
+static void           enigma_audio_port_put_buffer(xine_audio_port_t *port_gen, audio_buffer_t *buf, xine_stream_t *stream);
+
+
+
+void *enigma_audio_init_plugin(xine_t *xine, void *data)
+{
+  post_class_t *class = (post_class_t *)xine_xmalloc(sizeof (post_class_t));
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_audio_open_plugin;
+  class->identifier      = "enigma_audio";
+  class->description     = N_("modifies every audio frame as requested by ENIGMA2PC");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_audio_open_plugin(post_class_t *class_gen, int inputs,
+				      xine_audio_port_t **audio_target,
+				      xine_video_port_t **video_target)
+{
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)xine_xmalloc(sizeof (enigma_audio_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_audio_port_t       *port;
+/*
+fprintf(stderr, "~~~~~~~~~~ vdr open plugin\n");
+*/
+  if (!this || !audio_target || !audio_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  _x_post_init(&this->post_plugin, 1, 0);
+  this->post_plugin.dispose = enigma_audio_dispose;
+
+  port = _x_post_intercept_audio_port(&this->post_plugin, audio_target[ 0 ], &input, &output);
+  port->new_port.open       = enigma_audio_port_open;
+  port->new_port.put_buffer = enigma_audio_port_put_buffer;
+
+  this->post_plugin.xine_post.audio_input[ 0 ] = &port->new_port;
+
+
+
+  this->audio_channels = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_audio_dispose(post_plugin_t *this_gen)
+{
+/*
+fprintf(stderr, "~~~~~~~~~~ vdr dispose\n");
+*/
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+      xine_event_dispose_queue(this->event_queue);
+
+    free(this_gen);
+  }
+}
+
+static int enigma_audio_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                               uint32_t bits, uint32_t rate, int mode) {
+
+  post_audio_port_t       *port = (post_audio_port_t *)port_gen;
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)port->post;
+
+  _x_post_rewire(&this->post_plugin);
+  _x_post_inc_usage(port);
+/*
+fprintf(stderr, "~~~~~~~~~~ vdr port open\n");
+*/
+  port->stream = stream;
+  port->bits = bits;
+  port->rate = rate;
+  port->mode = mode;
+
+  this->num_channels = _x_ao_mode2channels(mode);
+
+  return (port->original_port->open) (port->original_port, stream, bits, rate, mode );
+}
+
+
+static void enigma_audio_port_put_buffer(xine_audio_port_t *port_gen, audio_buffer_t *buf, xine_stream_t *stream)
+{
+  post_audio_port_t       *port = (post_audio_port_t *)port_gen;
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)port->post;
+  xine_event_t *event;
+/*
+fprintf(stderr, "~~~~~~ vdr_audio\n");
+*/
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->audio_channels = 0;
+  }
+
+  if (!this->enigma_stream)
+//      && vdr_is_vdr_stream(stream))
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_VDR_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 1; /* vdr_audio */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_VDR_SELECTAUDIO)
+      {
+        enigma_select_audio_data_t *data = (enigma_select_audio_data_t *)event->data;
+
+        enigma_audio_select_audio(this, data->channels);
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  if (this->num_channels == 2
+      && this->audio_channels != 0
+      && this->audio_channels != 3)
+  {
+    audio_buffer_t *enigma_buf = port->original_port->get_buffer(port->original_port);
+    enigma_buf->num_frames = buf->num_frames;
+    enigma_buf->vpts = buf->vpts;
+    enigma_buf->frame_header_count = buf->frame_header_count;
+    enigma_buf->first_access_unit = buf->first_access_unit;
+    /* FIXME: The audio buffer should contain this info.
+     *        We should not have to get it from the open call.
+     */
+    enigma_buf->format.bits = buf->format.bits;
+    enigma_buf->format.rate = buf->format.rate;
+    enigma_buf->format.mode = buf->format.mode;
+    _x_extra_info_merge(enigma_buf->extra_info, buf->extra_info);
+
+    {
+      int step = buf->format.bits / 8;
+      uint8_t *src = (uint8_t *)buf->mem;
+      uint8_t *dst = (uint8_t *)enigma_buf->mem;
+
+      if (this->audio_channels == 2)
+        src += step;
+/*
+      fprintf(stderr, "~~~~~~~~~~ vdr port put buffer: channels: %d, %d\n"
+              , this->audio_channels
+              , buf->format.bits);
+*/
+      int i, k;
+      for (i = 0; i < buf->num_frames; i++)
+      {
+        for (k = 0; k < step; k++)
+          *dst++ = *src++;
+
+        src -= step;
+
+        for (k = 0; k < step; k++)
+          *dst++ = *src++;
+
+        src += step;
+      }
+    }
+
+    /* pass data to original port */
+    port->original_port->put_buffer(port->original_port, enigma_buf, stream);
+
+    /* free data from origial buffer */
+    buf->num_frames = 0; /* UNDOCUMENTED, but hey, it works! Force old audio_out buffer free. */
+  }
+
+  port->original_port->put_buffer(port->original_port, buf, stream);
+
+  return;
+}
--- a/enigma2pc/xine-lib/src/input/input_enigma.c	2013-09-04 13:13:43.000000000 +0400
+++ b/enigma2pc/xine-lib/src/input/input_enigma.c	2013-11-25 19:59:00.000000000 +0400
@@ -38,17 +38,64 @@
 
 #include <xine/xine_internal.h>
 #include <xine/input_plugin.h>
-#include "net_buf_ctrl.h"
+//#include "net_buf_ctrl.h"
 #include "combined_enigma.h"
 
+// xvdr
+#include <sys/time.h>
+
 #define ENIGMA_ABS_FIFO_DIR     "/tmp"
 #define DEFAULT_PTS_START       150000
 #define BUFSIZE                 768
 #define FILE_FLAGS O_RDONLY
 #define FIFO_PUT                0
 
+// xvdr 
+#define XVDR_METRONOM_OPTION_BASE  0x1001
+#define XVDR_METRONOM_LAST_VO_PTS  (XVDR_METRONOM_OPTION_BASE)
+#define XVDR_METRONOM_TRICK_SPEED  (XVDR_METRONOM_OPTION_BASE + 1)
+#define XVDR_METRONOM_STILL_MODE   (XVDR_METRONOM_OPTION_BASE + 2)
+#define XVDR_METRONOM_ID           (XVDR_METRONOM_OPTION_BASE + 3)
+
+#define XVDR_METRONOM_LIVE_BUFFERING   (XVDR_METRONOM_OPTION_BASE + 4)
+#define XVDR_METRONOM_STREAM_START     (XVDR_METRONOM_OPTION_BASE + 5)
+
 typedef struct enigma_input_plugin_s enigma_input_plugin_t;
 
+typedef struct 
+{
+  metronom_t          metronom;
+  metronom_t         *stream_metronom;
+  enigma_input_plugin_t *input;
+// xvdr 
+  int     trickspeed;    /* current trick speed */
+  int     still_mode;
+  int64_t last_vo_pts;   /* last displayed video frame PTS */
+  int     wired;         /* true if currently wired to stream */
+
+  /* initial buffering in live mode */
+  uint8_t  buffering;      /* buffering active */
+  uint8_t  live_buffering; /* live buffering enabled */
+  uint8_t  stream_start;
+  int64_t  vid_pts;        /* last seen video pts */
+  int64_t  aud_pts;        /* last seen audio pts */
+  int64_t  disc_pts;       /* reported discontinuity pts */
+  uint64_t buffering_start_time;
+  uint64_t first_frame_seen_time;
+
+  pthread_mutex_t mutex;
+}
+enigma_metronom_t;
+
+typedef struct enigma_vpts_offset_s enigma_vpts_offset_t;
+
+struct enigma_vpts_offset_s
+{
+  enigma_vpts_offset_t *next;
+  int64_t            vpts;
+  int64_t            offset;
+};
+
 struct enigma_input_plugin_s {
   input_plugin_t      input_plugin;
   xine_stream_t      *stream;
@@ -58,7 +105,51 @@
   char                seek_buf[BUFSIZE];
   xine_t             *xine;
   int                 last_disc_type;
-  nbc_t              *nbc;
+//  nbc_t              *nbc;
+
+  uint8_t             trick_speed_mode;
+  uint8_t             trick_speed_mode_blocked;
+  pthread_mutex_t     trick_speed_mode_lock;
+  pthread_cond_t      trick_speed_mode_cond;
+
+  pthread_t           metronom_thread;
+  pthread_mutex_t     metronom_thread_lock;
+  int64_t             metronom_thread_request;
+  int                 metronom_thread_reply;
+  pthread_cond_t      metronom_thread_request_cond;
+  pthread_cond_t      metronom_thread_reply_cond;
+  pthread_mutex_t     metronom_thread_call_lock;
+
+  uint8_t             find_sync_point;
+  pthread_mutex_t     find_sync_point_lock;
+
+  enigma_metronom_t      metronom;
+//  int                 last_disc_type;
+
+  enigma_vpts_offset_t  *vpts_offset_queue;
+  enigma_vpts_offset_t  *vpts_offset_queue_tail;
+  pthread_mutex_t     vpts_offset_queue_lock;
+  pthread_cond_t      vpts_offset_queue_changed_cond;
+  int                 vpts_offset_queue_changes;
+
+//* xvdr 
+  int     trickspeed;    // current trick speed
+  int     still_mode;
+  int64_t last_vo_pts;   // last displayed video frame PTS 
+  int     wired;         // true if currently wired to stream 
+
+  /* initial buffering in live mode */
+/*  uint8_t  buffering;      // buffering active 
+  uint8_t  live_buffering; // live buffering enabled 
+  uint8_t  stream_start;
+  int64_t  vid_pts;        // last seen video pts 
+  int64_t  aud_pts;        // last seen audio pts 
+  int64_t  disc_pts;       // reported discontinuity pts 
+  uint64_t buffering_start_time;
+  uint64_t first_frame_seen_time;
+
+  pthread_mutex_t mutex;
+*/
 };
 
 typedef struct {
@@ -66,259 +157,319 @@
   xine_t           *xine;
 } enigma_input_class_t;
 
+// xvdr
 
-/* Put callback the fifo mutex is locked */
-static void enigma_nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen) {
-  nbc_t *this = (nbc_t*)this_gen;
-  int64_t progress = 0;
-  int64_t video_p = 0;
-  int64_t audio_p = 0;
-  int force_dvbspeed = 0;
-  int has_video, has_audio;
-  force_dvbspeed = 0;
-  xine_t *xine = this->stream->xine;
-
-  cfg_entry_t *entry;
-	config_values_t *cfg;
-	cfg = xine->config;
-	entry = cfg->lookup_entry(cfg, "input.buffer.dynamic");
-  if  (strdup(entry->unknown_value) == "1");
-  			force_dvbspeed = 1;
+static uint64_t time_ms(void)
+{
+  struct timeval t;
+#ifdef XINEUTILS_H
+  if (xine_monotonic_clock(&t, NULL) == 0)
+#else
+  if (gettimeofday(&t, NULL) == 0)
+#endif
+     return ((uint64_t)t.tv_sec) * 1000ULL + t.tv_usec / 1000ULL;
+  return 0;
+}
 
-  lprintf("enter enigma_nbc_put_cb\n");
-  pthread_mutex_lock(&this->mutex);
+static uint64_t elapsed(uint64_t t)
+{
+  return time_ms() - t;
+}
 
-  if ((buf->type & BUF_MAJOR_MASK) != BUF_CONTROL_BASE) {
+static int warnings = 0;
 
-    if (this->enabled) {
-      if (this->dvbspeed)
-        dvbspeed_put (this, fifo, buf);
-      else {
-      nbc_compute_fifo_length(this, fifo, buf, FIFO_PUT);
-
-      if (this->buffering) {
-
-        has_video = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_VIDEO);
-        has_audio = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_AUDIO);
-        /* restart playing if high_water_mark is reached by all fifos
-         * do not restart if has_video and has_audio are false to avoid
-         * a yoyo effect at the beginning of the stream when these values
-         * are not yet known.
-         *
-         * be sure that the next buffer_pool_alloc() call will not deadlock,
-         * we need at least 2 buffers (see buffer.c)
-         */
-//printf("this->video_last_pts %lld   this->audio_last_pts %lld\n", this->video_last_pts, this->audio_last_pts);
-        int64_t first_pts = this->video_first_pts>this->audio_first_pts?this->video_first_pts:this->audio_first_pts;
-        int64_t last_pts = this->video_last_pts<this->audio_last_pts?this->video_last_pts:this->audio_last_pts;
-//printf("AAA first_pts %lld  last_pts %lld\n", first_pts, last_pts);
-        if ( has_video && has_audio && (last_pts-first_pts)>DEFAULT_PTS_START ) {
-          this->progress = 100;
-          //report_progress (this->stream, 100);
-          this->buffering = 0;
-          nbc_set_speed_normal(this);
-        }
-        else if ((((!has_video) || (this->video_fifo_length > this->high_water_mark)) &&
-             ((!has_audio) || (this->audio_fifo_length > this->high_water_mark)) &&
-             (has_video || has_audio))) {
-
-          this->progress = 100;
-          //report_progress (this->stream, 100);
-          this->buffering = 0;
-
-          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
-
-          nbc_set_speed_normal(this);
-
-          this->high_water_mark += this->high_water_mark / 2;
-
-        } else {
-          /*  compute the buffering progress
-           *    50%: video
-           *    50%: audio */
-          video_p = ((this->video_fifo_length * 50) / this->high_water_mark);
-          if (video_p > 50) video_p = 50;
-          audio_p = ((this->audio_fifo_length * 50) / this->high_water_mark);
-          if (audio_p > 50) audio_p = 50;
-
-          if ((has_video) && (has_audio)) {
-            progress = video_p + audio_p;
-          } else if (has_video) {
-            progress = 2 * video_p;
-          } else {
-            progress = 2 * audio_p;
-          }
-
-          /* if the progress can't be computed using the fifo length,
-             use the number of buffers */
-          if (!progress) {
-            video_p = this->video_fifo_fill;
-            audio_p = this->audio_fifo_fill;
-            progress = (video_p > audio_p) ? video_p : audio_p;
-          }
-
-          if (progress > this->progress) {
-            //report_progress (this->stream, progress);
-            this->progress = progress;
-          }
-        }
+static int64_t absdiff(int64_t a, int64_t b) { int64_t diff = a-b; if (diff<0) diff = -diff; return diff; }
+static int64_t min64(int64_t a, int64_t b) { return a < b ? a : b; }
+
+static void check_buffering_done(enigma_metronom_t *this)
+{
+  /* both audio and video timestamps seen ? */
+  if (this->vid_pts && this->aud_pts) {
+    int64_t da = this->aud_pts - this->disc_pts;
+    int64_t dv = this->vid_pts - this->disc_pts;
+    int64_t d_min = min64(da, dv);
+    printf("  stream A-V diff %d ms", (int)(this->vid_pts - this->aud_pts)/90);
+    printf("  reported stream start at pts %"PRId64, this->disc_pts);
+    printf("  output fifo end at: audio %"PRId64" video %"PRId64, this->aud_pts, this->vid_pts);
+    printf("  dA %"PRId64" dV %"PRId64, da, dv);
+    if (d_min < 0 && d_min > -10*90000) {
+      printf("  *** output is late %"PRId64" ticks (%"PRId64" ms) ***", d_min, -d_min/90);
+//      this->scr->jump(this->scr, d_min);
+    }
+    this->buffering = 0;
+    this->stream_start = 0;
+//    this->scr->set_buffering(this->scr, 0);
+    return;
+  }
+
+  if (this->first_frame_seen_time) {
+    int64_t ms_since_first_frame = elapsed(this->first_frame_seen_time);
+
+    if (ms_since_first_frame > 1000) {
+
+      this->stream_start = 0;
+
+      /* abort buffering if no audio */
+      if (this->vid_pts && !this->aud_pts) {
+        printf("buffering stopped: NO AUDIO ? elapsed time %d ms", (int)ms_since_first_frame);
+        this->buffering = 0;
+//        this->scr->set_buffering(this->scr, 0);
+        return;
       }
-      //if(this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
-      //  display_stats(this);
 
-      //report_stats(this, 0);
+      /* abort buffering if no video */
+      if (!this->vid_pts && this->aud_pts) {
+        printf("buffering stopped: NO VIDEO ? elapsed time %d ms", (int)ms_since_first_frame);
+        this->buffering = 0;
+//        this->scr->set_buffering(this->scr, 0);
+        return;
       }
-  	}
-  } else {
+    }
+  }
+}
 
-    switch (buf->type) {
-      case BUF_CONTROL_START:
-        lprintf("BUF_CONTROL_START\n");
-        if (!this->enabled) {
-          /* a new stream starts */
-          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: starts buffering\n");
-          this->enabled           = 1;
-          this->buffering         = 1;
-          this->video_first_pts   = 0;
-          this->video_last_pts    = 0;
-          this->audio_first_pts   = 0;
-          this->audio_last_pts    = 0;
-          this->video_fifo_length = 0;
-          this->audio_fifo_length = 0;
-          dvbspeed_init (this, force_dvbspeed);
-          if (!this->dvbspeed) nbc_set_speed_pause(this);
-/*          this->progress = 0;
-          report_progress (this->stream, progress);*/
-        }
-        break;
-      case BUF_CONTROL_NOP:
-        if (!(buf->decoder_flags & BUF_FLAG_END_USER) &&
-            !(buf->decoder_flags & BUF_FLAG_END_STREAM)) {
-          break;
-        }
-        /* fall through */
-      case BUF_CONTROL_END:
-      case BUF_CONTROL_QUIT:
-        lprintf("BUF_CONTROL_END\n");
-        dvbspeed_close (this);
-        if (this->enabled) {
-          /* end of stream :
-           *   - disable the nbc
-           *   - unpause the engine if buffering
-           */
-          this->enabled = 0;
-
-          lprintf("DISABLE netbuf\n");
-
-          if (this->buffering) {
-            this->buffering = 0;
-            this->progress = 100;
-            //report_progress (this->stream, this->progress);
+static void got_video_frame(metronom_t *self, vo_frame_t *frame)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  int64_t          pts  = frame->pts;
+/*
+#if 1 /* xine-lib master-slave metronom causes some problems ... * /
+  if (metronom->got_video_frame != got_video_frame) {
+    if (!warnings++)
+      LOGMSG("got_video_frame: invalid object");
+    return;
+  }
+  warnings = 0;
+#endif
+*/
+  if (this->still_mode) {
+    printf("Still frame, type %d", frame->picture_coding_type);
+    frame->pts       = 0;
+  }
 
-            xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+  if (this->trickspeed) {
+    frame->pts       = 0;
+    frame->duration *= 12; /* GOP */
+  }
 
-            nbc_set_speed_normal(this);
-          }
-        }
-        break;
+  /* initial buffering */
+  pthread_mutex_lock(&this->mutex);
+  if (this->buffering && !frame->bad_frame) {
 
-      case BUF_CONTROL_NEWPTS:
-        /* discontinuity management */
-        if (fifo == this->video_fifo) {
-          this->video_in_disc++;
-          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-		  "\nnet_buf_ctrl: enigma_nbc_put_cb video disc %d\n", this->video_in_disc);
-        } else {
-          this->audio_in_disc++;
-          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-		  "\nnet_buf_ctrl: enigma_nbc_put_cb audio disc %d\n", this->audio_in_disc);
-        }
-        break;
+    /* track video pts */
+    if (pts) {
+      if (this->vid_pts && (absdiff(this->vid_pts, pts) > 5*90000)) {
+        printf("buffering: video jump resetted audio pts");
+        this->aud_pts = 0;
+      }
+      if (this->vid_pts && this->aud_pts && (absdiff(this->vid_pts, this->aud_pts) > 5*90000)) {
+        printf("buffering: A-V diff resetted audio pts");
+        this->aud_pts = 0;
+      }
+      if (!this->vid_pts) {
+        printf("got video pts, frame type %d (@%d ms)", frame->picture_coding_type, (int)elapsed(this->buffering_start_time));
+        this->first_frame_seen_time = time_ms(); 
+      }
+      this->vid_pts = pts;
     }
 
-    if (fifo == this->video_fifo) {
-      this->video_fifo_free = fifo->buffer_pool_num_free;
-      this->video_fifo_size = fifo->fifo_data_size;
-    } else {
-      this->audio_fifo_free = fifo->buffer_pool_num_free;
-      this->audio_fifo_size = fifo->fifo_data_size;
+    /* some logging */
+    if (!pts) {
+      printf("got video, pts 0, buffering, frame type %d, bad_frame %d", frame->picture_coding_type, frame->bad_frame);
     }
+    if (pts && !frame->pts) {
+      printf("*** ERROR: hiding video pts while buffering ***");
+    }
+
+    check_buffering_done(this);
   }
+
   pthread_mutex_unlock(&this->mutex);
-  lprintf("exit enigma_nbc_put_cb\n");
+
+  this->stream_metronom->got_video_frame (this->stream_metronom, frame);
+
+  frame->pts = pts;
 }
 
-nbc_t *enigma_nbc_init (xine_stream_t *stream) {
+static int64_t got_audio_samples(metronom_t *self, int64_t pts, int nsamples)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
 
-  nbc_t *this = calloc(1, sizeof (nbc_t));
-  fifo_buffer_t *video_fifo = stream->video_fifo;
-  fifo_buffer_t *audio_fifo = stream->audio_fifo;
-  
-  
-  double video_fifo_factor, audio_fifo_factor;
-  cfg_entry_t *entry;
-
-  lprintf("enigma_nbc_init\n");
-  pthread_mutex_init (&this->mutex, NULL);
-
-  this->stream              = stream;
-  this->video_fifo          = video_fifo;
-  this->audio_fifo          = audio_fifo;
-
-  /* when the FIFO sizes are increased compared to the default configuration,
-   * apply a factor to the high water mark */
-  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.video_num_buffers");
-  /* No entry when no video output */
-  if (entry)
-    video_fifo_factor = (double)video_fifo->buffer_pool_capacity / (double)entry->num_default;
-  else
-    video_fifo_factor = 1.0;
-  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.audio_num_buffers");
-  /* When there's no audio output, there's no entry */
-  if (entry)
-    audio_fifo_factor = (double)audio_fifo->buffer_pool_capacity / (double)entry->num_default;
-  else
-    audio_fifo_factor = 1.0;
-  /* use the smaller factor */
-  if (video_fifo_factor < audio_fifo_factor)
-    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * video_fifo_factor;
-  else
-    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * audio_fifo_factor;
-
-  video_fifo->register_alloc_cb(video_fifo, nbc_alloc_cb, this);
-  video_fifo->register_put_cb(video_fifo, enigma_nbc_put_cb, this);
-  video_fifo->register_get_cb(video_fifo, nbc_get_cb, this);
-
-  audio_fifo->register_alloc_cb(audio_fifo, nbc_alloc_cb, this);
-  audio_fifo->register_put_cb(audio_fifo, enigma_nbc_put_cb, this);
-  audio_fifo->register_get_cb(audio_fifo, nbc_get_cb, this);
-
-  return this;
-}
-
-void enigma_nbc_close (nbc_t *this) {
-  fifo_buffer_t *video_fifo = this->stream->video_fifo;
-  fifo_buffer_t *audio_fifo = this->stream->audio_fifo;
-  xine_t        *xine       = this->stream->xine;
-
-  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close\n");
-
-  /* unregister all fifo callbacks */
-  /* do not lock the mutex to avoid deadlocks if a decoder calls fifo->get() */
-  video_fifo->unregister_alloc_cb(video_fifo, nbc_alloc_cb);
-  video_fifo->unregister_put_cb(video_fifo, enigma_nbc_put_cb);
-  video_fifo->unregister_get_cb(video_fifo, nbc_get_cb);
-
-  audio_fifo->unregister_alloc_cb(audio_fifo, nbc_alloc_cb);
-  audio_fifo->unregister_put_cb(audio_fifo, enigma_nbc_put_cb);
-  audio_fifo->unregister_get_cb(audio_fifo, nbc_get_cb);
+  pthread_mutex_lock(&this->mutex);
 
-  /* now we are sure that nobody will call a callback */
-  this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
+  /* initial buffering */
+  if (this->buffering) {
 
-  pthread_mutex_destroy(&this->mutex);
-  free (this);
-  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close: done\n");
+    /* track audio pts */
+    if (pts) {
+      if (this->aud_pts && (this->aud_pts > pts || absdiff(pts, this->aud_pts) > 5*90000)) {
+        printf("audio jump resetted video pts");
+        this->vid_pts = 0;
+      }
+      if (this->aud_pts && this->vid_pts && (absdiff(this->vid_pts, this->aud_pts) > 5*90000)) {
+        printf("buffering: A-V diff resetted video pts");
+        this->vid_pts = 0;
+      }
+      if (!this->aud_pts) {
+        printf("got audio pts (@%d ms)", (int)elapsed(this->buffering_start_time));
+        this->first_frame_seen_time = time_ms();
+      }
+      this->aud_pts = pts;
+    }
+
+    /* some logging */
+    if (!pts && !this->aud_pts) {
+      printf("got audio, pts 0, buffering");
+    }
+
+    check_buffering_done(this);
+  }
+
+  pthread_mutex_unlock(&this->mutex);
+
+  return this->stream_metronom->got_audio_samples (this->stream_metronom, pts, nsamples);
+}
+
+static int64_t got_spu_packet(metronom_t *self, int64_t pts)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  return this->stream_metronom->got_spu_packet(this->stream_metronom, pts);
+}
+
+static void start_buffering(enigma_metronom_t *this, int64_t disc_off)
+{
+  if (this->live_buffering && this->stream_start && disc_off) {
+    if (!this->buffering) {
+      printf("live mode buffering started (@%d ms)", (int)elapsed(this->buffering_start_time));
+
+      this->aud_pts  = 0;
+      this->vid_pts  = 0;
+      this->disc_pts = disc_off;
+
+      this->first_frame_seen_time = 0;
+
+      this->buffering = 1;
+//      this->scr->set_buffering(this->scr, 1);
+    }
+  } else {
+    if (this->buffering) {
+      printf("live mode buffering aborted (@%d ms)", (int)elapsed(this->buffering_start_time));
+      this->buffering = 0;
+//      this->scr->set_buffering(this->scr, 0);
+    }
+  }
+}
+
+static void handle_audio_discontinuity(metronom_t *self, int type, int64_t disc_off)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  start_buffering(this, disc_off);
+
+  this->stream_metronom->handle_audio_discontinuity(this->stream_metronom, type, disc_off);
+}
+
+static void handle_video_discontinuity(metronom_t *self, int type, int64_t disc_off)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  start_buffering(this, disc_off);
+
+  this->stream_metronom->handle_video_discontinuity(this->stream_metronom, type, disc_off);
+}
+
+static void set_audio_rate(metronom_t *self, int64_t pts_per_smpls)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  this->stream_metronom->set_audio_rate(this->stream_metronom, pts_per_smpls);
+}
+
+static void set_option(metronom_t *self, int option, int64_t value)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  if (option == XVDR_METRONOM_LAST_VO_PTS) {
+    if (value > 0) {
+      pthread_mutex_lock(&this->mutex);
+      this->last_vo_pts = value;
+      pthread_mutex_unlock(&this->mutex);
+    }
+    return;
+  }
+
+  if (option == XVDR_METRONOM_LIVE_BUFFERING) {
+    pthread_mutex_lock(&this->mutex);
+    this->live_buffering = value;
+    pthread_mutex_unlock(&this->mutex);
+    return;
+  }
+
+  if (option == XVDR_METRONOM_STREAM_START) {
+    pthread_mutex_lock(&this->mutex);
+    this->stream_start = 1;
+    this->buffering_start_time = time_ms();
+    pthread_mutex_unlock(&this->mutex);
+    return;
+  }
+
+  if (option == XVDR_METRONOM_TRICK_SPEED) {
+    this->trickspeed = value;
+    return;
+  }
+
+  if (option == XVDR_METRONOM_STILL_MODE) {
+    this->still_mode = value;
+    return;
+  }
+
+  this->stream_metronom->set_option(this->stream_metronom, option, value);
+}
+
+static int64_t get_option(metronom_t *self, int option)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  if (option == XVDR_METRONOM_LAST_VO_PTS) {
+    int64_t pts;
+    pthread_mutex_lock(&this->mutex);
+    pts = this->last_vo_pts;
+    pthread_mutex_unlock(&this->mutex);
+    return pts;
+  }
+  if (option == XVDR_METRONOM_TRICK_SPEED) {
+    return this->trickspeed;
+  }
+  if (option == XVDR_METRONOM_STILL_MODE) {
+    return this->still_mode;
+  }
+  if (option == XVDR_METRONOM_ID) {
+    return XVDR_METRONOM_ID;
+  }
+
+  return this->stream_metronom->get_option(this->stream_metronom, option);
+}
+
+static void set_master(metronom_t *self, metronom_t *master)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  this->stream_metronom->set_master(this->stream_metronom, master);
+}
+
+static void metronom_exit(metronom_t *self)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+/*  this->unwire(this);
+  this->stream = NULL;
+
+  if (this->orig_metronom) {
+    metronom_t *orig_metronom = this->orig_metronom;
+    this->orig_metronom = NULL;
+
+    orig_metronom->exit(orig_metronom);
+  }
+*/
+  _x_abort();
 }
 
 static off_t enigma_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
@@ -386,6 +537,52 @@
     total += n;
   }
 
+  if (this->find_sync_point
+    && total == 6)
+  {
+    pthread_mutex_lock(&this->find_sync_point_lock);
+
+    while (this->find_sync_point
+      && total == 6
+      && buf[0] == 0x00
+      && buf[1] == 0x00
+      && buf[2] == 0x01)
+    {
+      int l, sp;
+
+      if (buf[3] == 0xbe
+        && buf[4] == 0xff)
+      {
+/* fprintf(stderr, "------- seen sync point: %02x, waiting for: %02x\n", buf[5], this->find_sync_point); */
+        if (buf[5] == this->find_sync_point)
+        {
+          this->find_sync_point = 0;
+          break;
+        }
+      }
+
+      if ((buf[3] & 0xf0) != 0xe0
+        && (buf[3] & 0xe0) != 0xc0
+        && buf[3] != 0xbd
+        && buf[3] != 0xbe)
+      {
+        break;
+      }
+
+      l = buf[4] * 256 + buf[5];
+      if (l <= 0)
+         break;
+
+      sp = this->find_sync_point;
+      this->find_sync_point = 0;
+      this_gen->seek(this_gen, l, SEEK_CUR);
+      total = this_gen->read(this_gen, buf, 6);
+      this->find_sync_point = sp;
+    }
+
+    pthread_mutex_unlock(&this->find_sync_point_lock);
+  }
+
   return total;
 
 }
@@ -420,6 +617,8 @@
 }
 
 /* forward reference */
+static off_t enigma_plugin_get_current_pos(input_plugin_t *this_gen);
+
 static off_t enigma_plugin_seek (input_plugin_t *this_gen, off_t offset, int origin) {
 
   enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
@@ -493,21 +692,26 @@
 static void enigma_plugin_dispose (input_plugin_t *this_gen ) {
   enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
 
-  if (this->nbc) {
-    enigma_nbc_close (this->nbc);
-  }
+  pthread_mutex_destroy(&this->metronom.mutex);
+
+  pthread_mutex_destroy(&this->find_sync_point_lock); // need
+
 
   if (this->fh != -1)
     close(this->fh);
 
   free (this->mrl);
+
+  this->stream->metronom = this->metronom.stream_metronom;
+  this->metronom.stream_metronom = 0;
+
   free (this);
 }
 
 static int enigma_plugin_get_optional_data (input_plugin_t *this_gen,
 					   void *data, int data_type) {
   enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
-
+  (void)this; //Add from 
   switch (data_type)
   {
   case INPUT_OPTIONAL_DATA_PREVIEW:
@@ -531,7 +735,7 @@
   printf ("trying to open '%s'...\n", this->mrl);
 
   if (this->fh == -1) {
-    int err = 0;
+//    int err = 0;
     char *filename = (char *)ENIGMA_ABS_FIFO_DIR "/ENIGMA_FIFO";
     this->fh = open (filename, FILE_FLAGS);
 
@@ -562,7 +766,7 @@
   enigma_input_class_t  *class = (enigma_input_class_t *) class_gen;
   enigma_input_plugin_t *this;
   char                 *mrl = strdup(data);
-  int                   fh;
+//  int                   fh;
 
   if (!strncasecmp(mrl, "enigma:/", 8)) {
     lprintf("Enigma plugin\n");
@@ -597,11 +801,54 @@
   this->input_plugin.dispose           = enigma_plugin_dispose;
   this->input_plugin.get_optional_data = enigma_plugin_get_optional_data;
   this->input_plugin.input_class       = class_gen;
+/*
+  pthread_mutex_init(&this->trick_speed_mode_lock, 0);
+  pthread_cond_init(&this->trick_speed_mode_cond, 0);
+
+  pthread_mutex_init(&this->metronom_thread_lock, 0);
+  pthread_cond_init(&this->metronom_thread_request_cond, 0);
+  pthread_cond_init(&this->metronom_thread_reply_cond, 0);
+  pthread_mutex_init(&this->metronom_thread_call_lock, 0);
+*/
+  pthread_mutex_init(&this->find_sync_point_lock, 0);
+
+  this->metronom.input = this;
+/*  this->metronom.metronom.set_audio_rate             = enigma_metronom_set_audio_rate;
+  this->metronom.metronom.got_video_frame            = enigma_metronom_got_video_frame;
+  this->metronom.metronom.got_audio_samples          = enigma_metronom_got_audio_samples;
+  this->metronom.metronom.got_spu_packet             = enigma_metronom_got_spu_packet;
+  this->metronom.metronom.handle_audio_discontinuity = enigma_metronom_handle_audio_discontinuity;
+  this->metronom.metronom.handle_video_discontinuity = enigma_metronom_handle_video_discontinuity;
+  this->metronom.metronom.set_option                 = enigma_metronom_set_option;
+  this->metronom.metronom.get_option                 = enigma_metronom_get_option;
+  this->metronom.metronom.set_master                 = enigma_metronom_set_master;
+  this->metronom.metronom.exit                       = enigma_metronom_exit;
+*/
+
+// xvdr 
+  this->metronom.metronom.set_audio_rate             = set_audio_rate;
+  this->metronom.metronom.got_video_frame            = got_video_frame;
+  this->metronom.metronom.got_audio_samples          = got_audio_samples;
+  this->metronom.metronom.got_spu_packet             = got_spu_packet;
+  this->metronom.metronom.handle_audio_discontinuity = handle_audio_discontinuity;
+  this->metronom.metronom.handle_video_discontinuity = handle_video_discontinuity;
+  this->metronom.metronom.set_option                 = set_option;
+  this->metronom.metronom.get_option                 = get_option;
+  this->metronom.metronom.set_master                 = set_master;
+  this->metronom.metronom.exit                       = metronom_exit;
+
+  pthread_mutex_init(&this->metronom.mutex, NULL);
+
+  this->metronom.stream_metronom = stream->metronom;
+  stream->metronom = &this->metronom.metronom;
+
+//  pthread_mutex_init(&this->vpts_offset_queue_lock, 0);
+//  pthread_cond_init(&this->vpts_offset_queue_changed_cond, 0);
 
   /*
    * buffering control
    */
-  this->nbc    = enigma_nbc_init (this->stream);
+//  this->nbc    = enigma_nbc_init (this->stream);
 
   return &this->input_plugin;
 }
